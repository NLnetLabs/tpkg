#!/bin/bash

# a utlity to run a shar test archive (aka tpkg)
# Created by Miek Gieben, NLnetLabs, (c) 2005
# Licensed under GPL version 2

export TPKG_VAR=".tpkg.var"
export TPKG_VERSION="0.50";
export SHELL="/bin/sh"
TPKG_BASE="."
TPKG_ARGS=""
TPKG_CURRENT=`pwd`

### Helper functions
function cleanup() {
        err "[log] Cleaning up" 
        [ -f result.$dsc_basename ] && cp result.$dsc_basename ../
        cd ..
	if [ ! -z "$dir" ]; then
		if [ -d "$dir" ]; then
			rm -rf $dir
		fi
	fi
	cd $TPKG_CURRENT
}

function cleanup_and_exit() {
        cleanup
        exit 1
}

function err() {
        if [ -z $testname ]; then
                echo -e "  $1" > /dev/stderr
        else
                echo -e "[$testname]  $1" > /dev/stderr
        fi
}
function out() {
        if [ -z $testname ]; then
                echo -e "  $1"
        else
                echo -e "[$testname]  $1"
        fi
}

function post() {
        if [ -f "${dsc_post}" ]; then 
                err "[log] Executing post script"
                ${SHELL} ${dsc_post} ${TPKG_ARGS}
                if [ $? -ne 0 ]; then
                        err "[fatal] Post-script executed with errors: $?. Abort"
                        cleanup
                        exit 1
                fi
        fi
}

function pre() {
        if [ -f "${dsc_pre}" ]; then 
                err "[log] Executing pre-script"
                ${SHELL} ${dsc_pre} ${TPKG_ARGS}
                if [ $? -ne 0 ]; then
                        err "[fatal] Pre-script executed with errors: $?. Abort"
                        cleanup
                        exit 1
                fi
        fi
}
 
function write_done() {
        # we are executing in a subdir
        if [ -f "../.done-${testname}" ]; then
                err "[warning] Overwriting .done-${testname}"
        fi
        > ../.done-${testname}
}

function usage() {
        out "Usage:"
        out "$0 [OPTIONS] [exe|create|extract|tmpl] [report|clean] test.tpkg"
        out "or:"
        out "$0 [OPTIONS] clone test1.tpkg test2.tpkg"
        out
        out "Testing"
        out " exe....:\texecute a test, safe the result result.testname"
        out " create.:\tcreate a .tpkg out of the test.{pre, post, test} files"
        out " extract:\textract a .tpkg to tmp. dir"
        out " tmpl...:\tcreate empty template files for a new test"
        out
        out "Reporting/Cleanup"
        out " report.:\tcreate a nice report from all the result files"
        out " clean..:\tremove all the result files"
        out " clone..:\tclone test1.tpkg to test2.tkpg"
        out
        out " When multiple tests depend on a single other test, this"
        out " other test is only executed once."
	out
	out "OPTIONS"
	out "-h\t\tshow this help"
	out "-v\t\tshow version"
	out "-b DIR\tuse DIR is a base directory in stead of ."
	out "-a ARGS\tpass the string ARGS through to the test scripts"
        out 
        out " (c) NLnetLabs, Miek Gieben. Licensed under the GPL version 2."
}

function version() {
	out "tpkg (test package), version $TPKG_VERSION"
	out "Written by Miek Gieben, NLnet Labs"
	out
	out "Copyright (C) 2005 NLnet Labs"
	out
	out "This is free software; see the source for copying conditions. There is no"
	out "warranty; even not for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE"
}

function cleanreport() {
        # cleanup all the result. files
        for result in `ls result.* 2>/dev/null`; do 
                err "[log] rm $result"
                rm $result
        done
        # rm any .var files
        err "[log] rm $TPKG_VAR"
        rm -f $TPKG_VAR
        err "[log] rm .done files"
        rm -f .done*
	cd $TPKG_CURRENT
}

function report() {
        # generate a report from the result. files.
        passed=0
        failed=0
        unknown=0

        for result in `ls result.*`; do 
                passfailed=`head -1 $result | awk ' { print $2 }'`
                basename=`head -2 $result |grep BaseName | awk -F': ?' ' { print $2 }'`
                description=`head -3 $result |grep Description | awk -F': ?' ' { print $2 }'`
                
                case $passfailed in
                "FAILED")
                        ((failed=$failed + 1))
                        echo -e "$basename: !! $passfailed !! : $description"
                ;;
                "PASSED")
                        ((passed=$passed + 1))
                        echo -e "$basename: ** $passfailed ** : $description"
                ;;
                *) 
                        ((unknown=$unknown + 1))
                        echo -e "$basename: -- $passfailed -- : $description"
                ;;
                esac
        done
        ((total=$passed + $failed + $unknown))
        fper=`echo -e "scale=2\n$failed/$total*100" | bc`
        pper=`echo -e "scale=2\n$passed/$total*100" | bc`
        uper=`echo -e "scale=2\n$unknown/$total*100" | bc`
        echo
        echo -e "PASSED: $passed ($pper %)\t\tFAILED: $failed ($fper %)\t\tUNKNOWN: $unknown ($uper %)"
	cd $TPKG_CURRENT
}

# clone test1 to test2
function clone() {
        $0 extract $test1.tpkg
        
        if [ ! -d "$test1.dir" ]; then
                err "[fatal] No $test1.dir directory? Abort."
                exit 1
        fi
        cd $test1.dir
        for i in $test1.* ; do 
                ext=`echo $i | sed s/$test1//`
                if [ ! -z "$ext" ]; then
                        mv $i $test2$ext
                fi
        done
        # edit the dsc file too
        # don't use sed -i, its a gnu-ism
        sed  "s/$test1/$test2/g" < $test2.dsc > $test2.dsc.$$
        mv $test2.dsc.$$ $test2.dsc
        cd ..
        # rename the dir
        mv $test1.dir $test2.dir
        $0 create $test2.tpkg
	cd $TPKG_CURRENT
}

### Main 
# check the arguments
while getopts ":vhb:a:" o
do case "$o" in
	b) 	TPKG_BASE="$OPTARG";;
	h) 	usage; exit 0;;
	v) 	version; exit 0;;
	a) 	TPKG_ARGS="$OPTARG";;
esac
done
shift $(($OPTIND - 1))

# go to the base dir
if [ ! -d $TPKG_BASE ]; then
	err "[fatal] Directory $TPKG_BASE does not exist. Abort"
	exit 1
else
	cd $TPKG_BASE
fi

# either create a tpkg (ie. call shar) or exe (do a test)
goal=$1
archive=$2
if [ -z "${goal}" ]; then
        usage
	cd $TPKG_CURRENT
        exit 0
fi

### REPORT ###
# no extra args required
if [ "${goal}" = "report" ]; then
        report
        exit 0
fi
if [ "${goal}" = "clean" ]; then
        cleanreport
        exit 0
fi

if [ "${goal}" = "clone" ]; then
        test1=`basename $2 .tpkg`
        test2=`basename $3 .tpkg`;
        if [ -z "$test1" -o -z "$test2" ]; then
                usage
		cd $TPKG_CURRENT
                exit 0
        fi
        clone
        exit 0
fi

if [ -z $archive ]; then
        usage
	cd $TPKG_CURRENT
        exit 0
fi

testname=`basename $archive .tpkg`
dsc_file=$testname.dsc                  
if  [ -z $testname ]; then
        err "[fatal] The test package should have a .tpkg extension. Abort"
	cd $TPKG_CURRENT
        exit 1
fi


if [ $goal = "create" ]; then
### CREATE ###
# get all files with the same basename except those that ends in .tpkg

        # check for shar
        which shar >/dev/null
        if [ $? -ne 0 ]; then
                err "[fatal] Shar command not found. Abort"
                cd $TPKG_CURRENT
                exit 1
        fi

        # assume there is a dir named $testname.dir
        if [ ! -d "${testname}.dir" ]; then
                err "[fatal] No $testname.dir directory found. Abort."
        	cd $TPKG_CURRENT
                exit 1
        fi
        cd $testname.dir
        
        if [ -f $testname.tpkg ]; then
                err "[fatal] Not overwriting existing $testname.tpkg. Abort."
		cd $TPKG_CURRENT
                exit 1
        fi
        i=$( ls $testname.* 2>/dev/null )
        if [ -z "${i}" ]; then
                err "[fatal] No $testname.* files found. Abort."
		cd $TPKG_CURRENT
                exit 1
        fi
        shar $i > $testname.tpkg
        err "[log] Removing member files"
        rm $i
        mv $testname.tpkg ../
        cd ../
        rmdir $testname.dir
	cd $TPKG_CURRENT
        exit 0
fi

### TMPL ####
# write out a .dsc and touch a .pre/.post/.test
if [ $goal = "tmpl" ]; then
        if [ -f $testname.dsc ]; then
                err "[fatal] $testname.dsc already exists. Abort."
		cd $TPKG_CURRENT
                exit 1
        fi
        
        # make tmp dir
        dir="$testname.dir"
        mkdir $dir
        if [ ! -d $dir ]; then 
                err "[fatal] Failure to create a temporary working directory. Abort."
		cd $TPKG_CURRENT
                exit 1
        fi
        cd $dir
        
        cat <<TMPL_EOF > $testname.dsc
BaseName: $testname
Version: 1.0
Description: [Put something nice here]
CreationDate: `date`
Maintainer: `grep $LOGNAME /etc/passwd | awk -F: ' { print $5 }' | sed s/,//g`
Category: 
Component:
Depends: 
Pre: 
Post: 
Test: $testname.test
AuxFiles: 
Passed:
Failure:
TMPL_EOF
        echo "# source the var file when it's there" > $testname.test
        echo "[ -f ../$TPKG_VAR ] && source ../$TPKG_VAR" >> $testname.test 
        echo "# svnserve resets the path, you may need to adjust it, like this:" >> $testname.test
        echo "#export PATH=$PATH:/usr/sbin:/sbin:/usr/local/bin:/usr/local/sbin:." >> $testname.test

        out "[log] created $testname.{dsc, test}"
        out "[log] please create the test script(s) and then run: tpkg create $testname.tpkg"
        err "[log] created $testname in $dir."
        cd ..
	cd $TPKG_CURRENT
        exit 0
fi

## EXTRACT
if [ $goal = "extract" ]; then
        dir="${testname}.dir"
        if [ -d $dir ]; then 
                err "[fatal] Directory $dir already exists. Abort."
		cd $TPKG_CURRENT
                exit 1
        fi
        mkdir $dir
        if [ ! -d $dir ]; then 
                err "[fatal] Failure to create $dir directory. Abort."
		cd $TPKG_CURRENT
                exit 1
        fi

        err "[log] Extracting..."
        cp $archive $dir/
        cd $dir
        ${SHELL} ./$archive > /dev/null
        if [ $? -ne 0 ]; then
                err "[fatal] Could not unshar archive. Abort."
		cd $TPKG_CURRENT
                exit 1;
        fi

        trap cleanup_and_exit INT

        if [ $goal = "extract" ]; then
                # stop here
                err "[log] extracted $archive to $dir."
                rm $archive
		cd $TPKG_CURRENT
                exit 0
        fi
fi

# make a tmp dir during execution
if [ "$goal" != "extract" ]; then
        err "[fatal] What do you mean with $goal?. Abort"
	cd $TPKG_CURRENT
        exit 1
fi

dir=`mktemp -d "./$testname.XXXXXX"`
if [ ! -d $dir ]; then 
        err "[fatal] Failure to create a temporary working directory. Abort."
	cd $TPKG_CURRENT
        exit 1
fi
## EXTRACT
err "[log] Extracting..."
cp $archive $dir/
cd $dir
${SHELL} ./$archive > /dev/null
if [ $? -ne 0 ]; then
        err "[fatal] Could not unshar archive. Abort."
	cd $TPKG_CURRENT
        exit 1;
fi


### EXE ###
# extract the information out of the *.dsc files
if [ ! -f $dsc_file ]; then
        err "[fatal] Can't locate the description file: $dsc_file. Abort."
        cleanup
        exit 1
fi

SHELL=`which bash`
if [ -z ${SHELL} ]; then
       SHELL=/usr/local/bin/bash
       if [ ! -x $SHELL ]; then
               err "[fatal] Can't find the bash shell. Abort"
         	cleanup
               exit 1
       fi
fi

# check for a .done file
if [ -f "../.done-${testname}" ]; then
        err "[log] Found .done-${testname}. Not executing this test."
        cleanup
        exit 0
fi

# this is the template for .dsc files
# we need to check if all these files also exist TODO
dsc_basename=$testname
dsc_version=`IFS=: awk -F': ?' < $dsc_file '/^Version/ { print $2 }'`
dsc_description=`IFS=: awk -F': ?' < $dsc_file '/^Description/ { print $2 }'`
dsc_creationdate=`IFS=: awk -F': ?' < $dsc_file '/^CreationDate/ { print $2 }'`
dsc_category=`IFS=: awk -F': ?' < $dsc_file '/^Category/ { print $2 }'`
dsc_component=`IFS=: awk -F': ?' < $dsc_file '/^Component/ { print $2 }'`
dsc_depends=`IFS=: awk -F': ?' < $dsc_file '/^Depends/ { print $2 }'`
dsc_maintainer=`IFS=: awk -F': ?' < $dsc_file '/^Maintainer/ { print $2 }'`
dsc_pre=`IFS=: awk -F': ?' < $dsc_file '/^Pre/ { print $2 }'`
dsc_post=`IFS=: awk -F': ?' < $dsc_file '/^Post/ { print $2 }'`
dsc_test=`IFS=: awk -F': ?' < $dsc_file '/^Test/ { print $2 }'`
dsc_aux=`IFS=: awk -F': ?' < $dsc_file '/^AuxFiles/ { print $2 }'`
dsc_passed=`IFS=: awk -F': ?' < $dsc_file '/^Passed/ { print $2 }'`
dsc_failure=`IFS=: awk -F': ?' < $dsc_file '/^Failure/ { print $2 }'`

# if we depend on another test to that one first and then return
if [ -f "../${dsc_depends}" ]; then
        cd ..  # go up one dir
        err "[log] executing dependency test: $dsc_depends"
        ${SHELL} $0 "-b ${TPKG_BASE}" exe $dsc_depends
        test_result=$?
        cd - > /dev/null  # back where we belong
        if [ $test_result -ne 0 ]; then
                err "[fatal] Test depends on $dsc_depends which failed.  Abort."
                cleanup
                exit 1;
        fi
fi

# this enhances the template from above
## Post Processing of some of these variables
# dsc_aux is a comma seperated list of files, max 8 files
i=$( echo $dsc_aux | awk -F', ?' '{ print $1 "\n" $2 "\n" $3 "\n" $4 "\n" \
$5 "\n" $6 "\n" $7 "\n" $8 }' )
dsc_aux_files=($i)
dsc_aux_files_total=${#dsc_aux_files[*]}
# depends can also be a comma seperated list of package
# TODO

# check is the aux files are also really in the shar
for i in ${dsc_aux_files[*]}; do
        if [ ! -f $i ]; then
                err "[fatal] Aux. file $i must be in the archive. Abort"
                cleanup
                exit 1
        fi
done

if [ ! -f $dsc_test ]; then
        err "[fatal] Can't locate the test script: $dsc_test. Abort"
        cleanup
        exit 1
fi

### Actual executing of the scripts
pre

err "[log] Executing test" 
# save the test output in a file together with some extra info
# TODO put other values into here too??
echo "BaseName: $dsc_basename" > result.$dsc_basename
echo "Description: $dsc_description" >> result.$dsc_basename
echo "DateRun: `date`" >> result.$dsc_basename
echo "--------------- Test Output ------------------" >> result.$dsc_basename
( ${SHELL} $dsc_test ${TPKG_ARGS} 2>&1 ) >> result.$dsc_basename
test_result=$?
if [ $test_result -ne 0 ]; then
        err "[warning] Test executed with errors: $test_result." 
        echo "!! FAILED !!     !! FAILED !!" > result.$dsc_basename.tmp
        err "[log] !! FAILED !!"
        cat result.$dsc_basename >> result.$dsc_basename.tmp
        mv result.$dsc_basename.tmp result.$dsc_basename
        post
        cleanup
        exit 1
fi
# 
cp -f result.$dsc_basename result.$dsc_basename.$$

failed=-1  # -1 undef, 0 passed, 1 failed
## PASSED
# not we can both fail and pass... TODO???
[ ! -z "${dsc_passed}" ] && egrep "${dsc_passed}" result.$dsc_basename.$$ > /dev/null
if [ $? -eq 0 ]; then
        echo "** PASSED **     ** PASSED **" > result.$dsc_basename.tmp
        err "[log] ** PASSED **"
        cat result.$dsc_basename >> result.$dsc_basename.tmp
        mv result.$dsc_basename.tmp result.$dsc_basename
        write_done
        failed=0
fi 
## FAILED
[ ! -z "${dsc_failure}" ] && egrep "${dsc_failure}" result.$dsc_basename.$$ > /dev/null
# if not found this actually means PASSED
if [ $? -eq 0 ]; then
        echo "!! FAILED !!     !! FAILED !!" > result.$dsc_basename.tmp
        err "[log] !! FAILED !!"
        cat result.$dsc_basename >> result.$dsc_basename.tmp
        mv result.$dsc_basename.tmp result.$dsc_basename
        failed=1
else
        echo "** PASSED **     ** PASSED **" > result.$dsc_basename.tmp
        err "[log] ** PASSED **"
        cat result.$dsc_basename >> result.$dsc_basename.tmp
        mv result.$dsc_basename.tmp result.$dsc_basename
        write_done
        failed=0
fi

## UNKNOWN
if [ $failed -eq -1 ]; then
        # neither failed, not success, unknown
        # test script exited with non-zero value, failed!
        echo "-- UNKNOWN --     -- UNKNOWN --" > result.$dsc_basename.tmp
        err "[log] -- UNKNOWN --"
        cat result.$dsc_basename >> result.$dsc_basename.tmp
        mv result.$dsc_basename.tmp result.$dsc_basename
        write_done
        failed=1 # not passed
fi
        
post
cleanup
exit $failed
